{"version":3,"sources":["../src/core/db.ts","../src/core/memory.ts","../src/core/path.ts","../src/core/link.ts","../src/core/snapshot.ts","../src/core/guard.ts"],"sourcesContent":["// AgentMemory v2 — SQLite database initialization and schema\nimport Database from \"better-sqlite3\";\nimport { randomUUID } from \"crypto\";\n\nexport const SCHEMA_VERSION = 1;\n\nconst SCHEMA_SQL = `\n-- Memory entries\nCREATE TABLE IF NOT EXISTS memories (\n  id            TEXT PRIMARY KEY,\n  content       TEXT NOT NULL,\n  type          TEXT NOT NULL CHECK(type IN ('identity','emotion','knowledge','event')),\n  priority      INTEGER NOT NULL DEFAULT 2 CHECK(priority BETWEEN 0 AND 3),\n  emotion_val   REAL NOT NULL DEFAULT 0.0,\n  vitality      REAL NOT NULL DEFAULT 1.0,\n  stability     REAL NOT NULL DEFAULT 1.0,\n  access_count  INTEGER NOT NULL DEFAULT 0,\n  last_accessed TEXT,\n  created_at    TEXT NOT NULL,\n  updated_at    TEXT NOT NULL,\n  source        TEXT,\n  agent_id      TEXT NOT NULL DEFAULT 'default',\n  hash          TEXT,\n  UNIQUE(hash, agent_id)\n);\n\n-- URI paths (Content-Path separation, from nocturne)\nCREATE TABLE IF NOT EXISTS paths (\n  id          TEXT PRIMARY KEY,\n  memory_id   TEXT NOT NULL REFERENCES memories(id) ON DELETE CASCADE,\n  uri         TEXT NOT NULL UNIQUE,\n  alias       TEXT,\n  domain      TEXT NOT NULL,\n  created_at  TEXT NOT NULL\n);\n\n-- Association network (knowledge graph)\nCREATE TABLE IF NOT EXISTS links (\n  source_id   TEXT NOT NULL REFERENCES memories(id) ON DELETE CASCADE,\n  target_id   TEXT NOT NULL REFERENCES memories(id) ON DELETE CASCADE,\n  relation    TEXT NOT NULL,\n  weight      REAL NOT NULL DEFAULT 1.0,\n  created_at  TEXT NOT NULL,\n  PRIMARY KEY (source_id, target_id)\n);\n\n-- Snapshots (version control, from nocturne + Memory Palace)\nCREATE TABLE IF NOT EXISTS snapshots (\n  id          TEXT PRIMARY KEY,\n  memory_id   TEXT NOT NULL REFERENCES memories(id) ON DELETE CASCADE,\n  content     TEXT NOT NULL,\n  changed_by  TEXT,\n  action      TEXT NOT NULL CHECK(action IN ('create','update','delete','merge')),\n  created_at  TEXT NOT NULL\n);\n\n-- Full-text search index (BM25)\nCREATE VIRTUAL TABLE IF NOT EXISTS memories_fts USING fts5(\n  id UNINDEXED,\n  content,\n  tokenize='unicode61'\n);\n\n-- Schema version tracking\nCREATE TABLE IF NOT EXISTS schema_meta (\n  key   TEXT PRIMARY KEY,\n  value TEXT NOT NULL\n);\n\n-- Indexes for common queries\nCREATE INDEX IF NOT EXISTS idx_memories_type ON memories(type);\nCREATE INDEX IF NOT EXISTS idx_memories_priority ON memories(priority);\nCREATE INDEX IF NOT EXISTS idx_memories_agent ON memories(agent_id);\nCREATE INDEX IF NOT EXISTS idx_memories_vitality ON memories(vitality);\nCREATE INDEX IF NOT EXISTS idx_memories_hash ON memories(hash);\nCREATE INDEX IF NOT EXISTS idx_paths_memory ON paths(memory_id);\nCREATE INDEX IF NOT EXISTS idx_paths_domain ON paths(domain);\nCREATE INDEX IF NOT EXISTS idx_links_source ON links(source_id);\nCREATE INDEX IF NOT EXISTS idx_links_target ON links(target_id);\n`;\n\nexport interface DbOptions {\n  path: string;\n  walMode?: boolean;\n}\n\nexport function openDatabase(opts: DbOptions): Database.Database {\n  const db = new Database(opts.path);\n\n  // Enable WAL mode for better concurrent read performance\n  if (opts.walMode !== false) {\n    db.pragma(\"journal_mode = WAL\");\n  }\n  db.pragma(\"foreign_keys = ON\");\n  db.pragma(\"busy_timeout = 5000\");\n\n  // Run schema creation\n  db.exec(SCHEMA_SQL);\n\n  // Track schema version\n  const getVersion = db.prepare(\"SELECT value FROM schema_meta WHERE key = 'version'\");\n  const row = getVersion.get() as { value: string } | undefined;\n  if (!row) {\n    db.prepare(\"INSERT INTO schema_meta (key, value) VALUES ('version', ?)\").run(\n      String(SCHEMA_VERSION),\n    );\n  }\n\n  return db;\n}\n\nexport function now(): string {\n  return new Date().toISOString();\n}\n\nexport function newId(): string {\n  return randomUUID();\n}\n","// AgentMemory v2 — Memory CRUD operations\nimport { createHash } from \"crypto\";\nimport type Database from \"better-sqlite3\";\nimport { newId, now } from \"./db.js\";\n\nexport type MemoryType = \"identity\" | \"emotion\" | \"knowledge\" | \"event\";\nexport type Priority = 0 | 1 | 2 | 3;\n\nexport interface Memory {\n  id: string;\n  content: string;\n  type: MemoryType;\n  priority: Priority;\n  emotion_val: number;\n  vitality: number;\n  stability: number;\n  access_count: number;\n  last_accessed: string | null;\n  created_at: string;\n  updated_at: string;\n  source: string | null;\n  agent_id: string;\n  hash: string | null;\n}\n\nexport interface CreateMemoryInput {\n  content: string;\n  type: MemoryType;\n  priority?: Priority;\n  emotion_val?: number;\n  source?: string;\n  agent_id?: string;\n}\n\nexport interface UpdateMemoryInput {\n  content?: string;\n  type?: MemoryType;\n  priority?: Priority;\n  emotion_val?: number;\n  vitality?: number;\n  stability?: number;\n  source?: string;\n}\n\nexport function contentHash(content: string): string {\n  return createHash(\"sha256\").update(content.trim()).digest(\"hex\").slice(0, 16);\n}\n\n// Priority defaults based on type\nconst TYPE_PRIORITY: Record<MemoryType, Priority> = {\n  identity: 0,\n  emotion: 1,\n  knowledge: 2,\n  event: 3,\n};\n\n// Initial stability (Ebbinghaus S parameter) based on priority\nconst PRIORITY_STABILITY: Record<Priority, number> = {\n  0: Infinity, // P0: never decays\n  1: 365, // P1: 365-day half-life\n  2: 90, // P2: 90-day half-life\n  3: 14, // P3: 14-day half-life\n};\n\nexport function createMemory(db: Database.Database, input: CreateMemoryInput): Memory | null {\n  const hash = contentHash(input.content);\n  const agentId = input.agent_id ?? \"default\";\n  const priority = input.priority ?? TYPE_PRIORITY[input.type];\n  const stability = PRIORITY_STABILITY[priority];\n\n  // Dedup: check if identical content already exists for this agent\n  const existing = db\n    .prepare(\"SELECT id FROM memories WHERE hash = ? AND agent_id = ?\")\n    .get(hash, agentId) as { id: string } | undefined;\n  if (existing) {\n    return null; // Already exists, skip\n  }\n\n  const id = newId();\n  const timestamp = now();\n\n  db.prepare(\n    `INSERT INTO memories (id, content, type, priority, emotion_val, vitality, stability,\n     access_count, created_at, updated_at, source, agent_id, hash)\n     VALUES (?, ?, ?, ?, ?, 1.0, ?, 0, ?, ?, ?, ?, ?)`,\n  ).run(\n    id,\n    input.content,\n    input.type,\n    priority,\n    input.emotion_val ?? 0.0,\n    stability === Infinity ? 999999 : stability,\n    timestamp,\n    timestamp,\n    input.source ?? null,\n    agentId,\n    hash,\n  );\n\n  // Sync to FTS index\n  db.prepare(\"INSERT INTO memories_fts (id, content) VALUES (?, ?)\").run(id, input.content);\n\n  return getMemory(db, id)!;\n}\n\nexport function getMemory(db: Database.Database, id: string): Memory | null {\n  return (db.prepare(\"SELECT * FROM memories WHERE id = ?\").get(id) as Memory) ?? null;\n}\n\nexport function updateMemory(\n  db: Database.Database,\n  id: string,\n  input: UpdateMemoryInput,\n): Memory | null {\n  const existing = getMemory(db, id);\n  if (!existing) return null;\n\n  const fields: string[] = [];\n  const values: unknown[] = [];\n\n  if (input.content !== undefined) {\n    fields.push(\"content = ?\", \"hash = ?\");\n    values.push(input.content, contentHash(input.content));\n  }\n  if (input.type !== undefined) {\n    fields.push(\"type = ?\");\n    values.push(input.type);\n  }\n  if (input.priority !== undefined) {\n    fields.push(\"priority = ?\");\n    values.push(input.priority);\n  }\n  if (input.emotion_val !== undefined) {\n    fields.push(\"emotion_val = ?\");\n    values.push(input.emotion_val);\n  }\n  if (input.vitality !== undefined) {\n    fields.push(\"vitality = ?\");\n    values.push(input.vitality);\n  }\n  if (input.stability !== undefined) {\n    fields.push(\"stability = ?\");\n    values.push(input.stability);\n  }\n  if (input.source !== undefined) {\n    fields.push(\"source = ?\");\n    values.push(input.source);\n  }\n\n  fields.push(\"updated_at = ?\");\n  values.push(now());\n  values.push(id);\n\n  db.prepare(`UPDATE memories SET ${fields.join(\", \")} WHERE id = ?`).run(...values);\n\n  // Update FTS if content changed\n  if (input.content !== undefined) {\n    db.prepare(\"DELETE FROM memories_fts WHERE id = ?\").run(id);\n    db.prepare(\"INSERT INTO memories_fts (id, content) VALUES (?, ?)\").run(id, input.content);\n  }\n\n  return getMemory(db, id);\n}\n\nexport function deleteMemory(db: Database.Database, id: string): boolean {\n  // FTS cleanup\n  db.prepare(\"DELETE FROM memories_fts WHERE id = ?\").run(id);\n  const result = db.prepare(\"DELETE FROM memories WHERE id = ?\").run(id);\n  return result.changes > 0;\n}\n\nexport function listMemories(\n  db: Database.Database,\n  opts?: {\n    agent_id?: string;\n    type?: MemoryType;\n    priority?: Priority;\n    min_vitality?: number;\n    limit?: number;\n    offset?: number;\n  },\n): Memory[] {\n  const conditions: string[] = [];\n  const params: unknown[] = [];\n\n  if (opts?.agent_id) {\n    conditions.push(\"agent_id = ?\");\n    params.push(opts.agent_id);\n  }\n  if (opts?.type) {\n    conditions.push(\"type = ?\");\n    params.push(opts.type);\n  }\n  if (opts?.priority !== undefined) {\n    conditions.push(\"priority = ?\");\n    params.push(opts.priority);\n  }\n  if (opts?.min_vitality !== undefined) {\n    conditions.push(\"vitality >= ?\");\n    params.push(opts.min_vitality);\n  }\n\n  const where = conditions.length ? `WHERE ${conditions.join(\" AND \")}` : \"\";\n  const limit = opts?.limit ?? 100;\n  const offset = opts?.offset ?? 0;\n\n  return db\n    .prepare(`SELECT * FROM memories ${where} ORDER BY priority ASC, updated_at DESC LIMIT ? OFFSET ?`)\n    .all(...params, limit, offset) as Memory[];\n}\n\nexport function recordAccess(db: Database.Database, id: string, growthFactor = 1.5): void {\n  const mem = getMemory(db, id);\n  if (!mem) return;\n\n  const newStability = Math.min(999999, mem.stability * growthFactor);\n\n  db.prepare(\n    `UPDATE memories SET access_count = access_count + 1, last_accessed = ?, stability = ?,\n     vitality = MIN(1.0, vitality * 1.2) WHERE id = ?`,\n  ).run(now(), newStability, id);\n}\n\nexport function countMemories(\n  db: Database.Database,\n  agent_id = \"default\",\n): { total: number; by_type: Record<string, number>; by_priority: Record<string, number> } {\n  const total = (\n    db.prepare(\"SELECT COUNT(*) as c FROM memories WHERE agent_id = ?\").get(agent_id) as {\n      c: number;\n    }\n  ).c;\n\n  const byType = db\n    .prepare(\"SELECT type, COUNT(*) as c FROM memories WHERE agent_id = ? GROUP BY type\")\n    .all(agent_id) as Array<{ type: string; c: number }>;\n\n  const byPriority = db\n    .prepare(\"SELECT priority, COUNT(*) as c FROM memories WHERE agent_id = ? GROUP BY priority\")\n    .all(agent_id) as Array<{ priority: number; c: number }>;\n\n  return {\n    total,\n    by_type: Object.fromEntries(byType.map((r) => [r.type, r.c])),\n    by_priority: Object.fromEntries(byPriority.map((r) => [`P${r.priority}`, r.c])),\n  };\n}\n","// AgentMemory v2 — URI path system (from nocturne's Content-Path separation)\nimport type Database from \"better-sqlite3\";\nimport { newId, now } from \"./db.js\";\n\nexport interface Path {\n  id: string;\n  memory_id: string;\n  uri: string;\n  alias: string | null;\n  domain: string;\n  created_at: string;\n}\n\n// Valid domains (extensible)\nconst DEFAULT_DOMAINS = new Set([\"core\", \"emotion\", \"knowledge\", \"event\", \"system\"]);\n\nexport function parseUri(uri: string): { domain: string; path: string } {\n  const match = uri.match(/^([a-z]+):\\/\\/(.+)$/);\n  if (!match) throw new Error(`Invalid URI: ${uri}. Expected format: domain://path`);\n  return { domain: match[1], path: match[2] };\n}\n\nexport function createPath(\n  db: Database.Database,\n  memoryId: string,\n  uri: string,\n  alias?: string,\n  validDomains?: Set<string>,\n): Path {\n  const { domain } = parseUri(uri);\n  const domains = validDomains ?? DEFAULT_DOMAINS;\n  if (!domains.has(domain)) {\n    throw new Error(`Invalid domain \"${domain}\". Valid: ${[...domains].join(\", \")}`);\n  }\n\n  // Check URI uniqueness\n  const existing = db.prepare(\"SELECT id FROM paths WHERE uri = ?\").get(uri) as\n    | { id: string }\n    | undefined;\n  if (existing) {\n    throw new Error(`URI already exists: ${uri}`);\n  }\n\n  const id = newId();\n  db.prepare(\n    \"INSERT INTO paths (id, memory_id, uri, alias, domain, created_at) VALUES (?, ?, ?, ?, ?, ?)\",\n  ).run(id, memoryId, uri, alias ?? null, domain, now());\n\n  return getPath(db, id)!;\n}\n\nexport function getPath(db: Database.Database, id: string): Path | null {\n  return (db.prepare(\"SELECT * FROM paths WHERE id = ?\").get(id) as Path) ?? null;\n}\n\nexport function getPathByUri(db: Database.Database, uri: string): Path | null {\n  return (db.prepare(\"SELECT * FROM paths WHERE uri = ?\").get(uri) as Path) ?? null;\n}\n\nexport function getPathsByMemory(db: Database.Database, memoryId: string): Path[] {\n  return db.prepare(\"SELECT * FROM paths WHERE memory_id = ?\").all(memoryId) as Path[];\n}\n\nexport function getPathsByDomain(db: Database.Database, domain: string): Path[] {\n  return db\n    .prepare(\"SELECT * FROM paths WHERE domain = ? ORDER BY uri\")\n    .all(domain) as Path[];\n}\n\nexport function getPathsByPrefix(db: Database.Database, prefix: string): Path[] {\n  return db\n    .prepare(\"SELECT * FROM paths WHERE uri LIKE ? ORDER BY uri\")\n    .all(`${prefix}%`) as Path[];\n}\n\nexport function deletePath(db: Database.Database, id: string): boolean {\n  const result = db.prepare(\"DELETE FROM paths WHERE id = ?\").run(id);\n  return result.changes > 0;\n}\n\nexport function deletePathsByMemory(db: Database.Database, memoryId: string): number {\n  const result = db.prepare(\"DELETE FROM paths WHERE memory_id = ?\").run(memoryId);\n  return result.changes;\n}\n","// AgentMemory v2 — Association links (knowledge graph)\nimport type Database from \"better-sqlite3\";\nimport { newId, now } from \"./db.js\";\n\nexport type RelationType = \"related\" | \"caused\" | \"reminds\" | \"evolved\" | \"contradicts\";\n\nexport interface Link {\n  source_id: string;\n  target_id: string;\n  relation: RelationType;\n  weight: number;\n  created_at: string;\n}\n\nexport function createLink(\n  db: Database.Database,\n  sourceId: string,\n  targetId: string,\n  relation: RelationType,\n  weight = 1.0,\n): Link {\n  db.prepare(\n    `INSERT OR REPLACE INTO links (source_id, target_id, relation, weight, created_at)\n     VALUES (?, ?, ?, ?, ?)`,\n  ).run(sourceId, targetId, relation, weight, now());\n\n  return { source_id: sourceId, target_id: targetId, relation, weight, created_at: now() };\n}\n\nexport function getLinks(db: Database.Database, memoryId: string): Link[] {\n  return db\n    .prepare(\"SELECT * FROM links WHERE source_id = ? OR target_id = ?\")\n    .all(memoryId, memoryId) as Link[];\n}\n\nexport function getOutgoingLinks(db: Database.Database, sourceId: string): Link[] {\n  return db.prepare(\"SELECT * FROM links WHERE source_id = ?\").all(sourceId) as Link[];\n}\n\n/**\n * Multi-hop traversal: find all memories reachable within N hops\n * Inspired by PowerMem's knowledge graph traversal\n */\nexport function traverse(\n  db: Database.Database,\n  startId: string,\n  maxHops = 2,\n): Array<{ id: string; hop: number; relation: string }> {\n  const visited = new Set<string>();\n  const results: Array<{ id: string; hop: number; relation: string }> = [];\n  const queue: Array<{ id: string; hop: number; relation: string }> = [\n    { id: startId, hop: 0, relation: \"self\" },\n  ];\n\n  while (queue.length > 0) {\n    const current = queue.shift()!;\n    if (visited.has(current.id)) continue;\n    visited.add(current.id);\n\n    if (current.hop > 0) {\n      results.push(current);\n    }\n\n    if (current.hop < maxHops) {\n      const links = db\n        .prepare(\"SELECT target_id, relation FROM links WHERE source_id = ?\")\n        .all(current.id) as Array<{ target_id: string; relation: string }>;\n\n      for (const link of links) {\n        if (!visited.has(link.target_id)) {\n          queue.push({\n            id: link.target_id,\n            hop: current.hop + 1,\n            relation: link.relation,\n          });\n        }\n      }\n\n      // Also traverse reverse links\n      const reverseLinks = db\n        .prepare(\"SELECT source_id, relation FROM links WHERE target_id = ?\")\n        .all(current.id) as Array<{ source_id: string; relation: string }>;\n\n      for (const link of reverseLinks) {\n        if (!visited.has(link.source_id)) {\n          queue.push({\n            id: link.source_id,\n            hop: current.hop + 1,\n            relation: link.relation,\n          });\n        }\n      }\n    }\n  }\n\n  return results;\n}\n\nexport function deleteLink(\n  db: Database.Database,\n  sourceId: string,\n  targetId: string,\n): boolean {\n  const result = db\n    .prepare(\"DELETE FROM links WHERE source_id = ? AND target_id = ?\")\n    .run(sourceId, targetId);\n  return result.changes > 0;\n}\n","// AgentMemory v2 — Snapshot system (version control, from nocturne + Memory Palace)\nimport type Database from \"better-sqlite3\";\nimport { newId, now } from \"./db.js\";\n\nexport type SnapshotAction = \"create\" | \"update\" | \"delete\" | \"merge\";\n\nexport interface Snapshot {\n  id: string;\n  memory_id: string;\n  content: string;\n  changed_by: string | null;\n  action: SnapshotAction;\n  created_at: string;\n}\n\n/**\n * Create a snapshot before modifying a memory.\n * Call this BEFORE any update/delete operation.\n */\nexport function createSnapshot(\n  db: Database.Database,\n  memoryId: string,\n  action: SnapshotAction,\n  changedBy?: string,\n): Snapshot {\n  const memory = db.prepare(\"SELECT content FROM memories WHERE id = ?\").get(memoryId) as\n    | { content: string }\n    | undefined;\n\n  if (!memory) throw new Error(`Memory not found: ${memoryId}`);\n\n  const id = newId();\n  db.prepare(\n    `INSERT INTO snapshots (id, memory_id, content, changed_by, action, created_at)\n     VALUES (?, ?, ?, ?, ?, ?)`,\n  ).run(id, memoryId, memory.content, changedBy ?? null, action, now());\n\n  return { id, memory_id: memoryId, content: memory.content, changed_by: changedBy ?? null, action, created_at: now() };\n}\n\nexport function getSnapshots(db: Database.Database, memoryId: string): Snapshot[] {\n  return db\n    .prepare(\"SELECT * FROM snapshots WHERE memory_id = ? ORDER BY created_at DESC\")\n    .all(memoryId) as Snapshot[];\n}\n\nexport function getSnapshot(db: Database.Database, id: string): Snapshot | null {\n  return (db.prepare(\"SELECT * FROM snapshots WHERE id = ?\").get(id) as Snapshot) ?? null;\n}\n\n/**\n * Rollback a memory to a specific snapshot.\n * Creates a new snapshot of the current state before rolling back.\n */\nexport function rollback(db: Database.Database, snapshotId: string): boolean {\n  const snapshot = getSnapshot(db, snapshotId);\n  if (!snapshot) return false;\n\n  // Snapshot current state before rollback\n  createSnapshot(db, snapshot.memory_id, \"update\", \"rollback\");\n\n  // Restore content\n  db.prepare(\"UPDATE memories SET content = ?, updated_at = ? WHERE id = ?\").run(\n    snapshot.content,\n    now(),\n    snapshot.memory_id,\n  );\n\n  // Update FTS\n  db.prepare(\"DELETE FROM memories_fts WHERE id = ?\").run(snapshot.memory_id);\n  db.prepare(\"INSERT INTO memories_fts (id, content) VALUES (?, ?)\").run(\n    snapshot.memory_id,\n    snapshot.content,\n  );\n\n  return true;\n}\n\nexport function deleteSnapshots(db: Database.Database, memoryId: string): number {\n  const result = db.prepare(\"DELETE FROM snapshots WHERE memory_id = ?\").run(memoryId);\n  return result.changes;\n}\n","// AgentMemory v2 — Write Guard (dedup + conflict detection + 4-criterion gate)\nimport type Database from \"better-sqlite3\";\nimport { contentHash, type CreateMemoryInput, type Memory } from \"./memory.js\";\nimport { getPathByUri } from \"./path.js\";\n\nexport type GuardAction = \"add\" | \"update\" | \"skip\" | \"merge\";\n\nexport interface GuardResult {\n  action: GuardAction;\n  reason: string;\n  existingId?: string;\n  mergedContent?: string;\n}\n\n/**\n * Write Guard — decides whether to add, update, skip, or merge a memory.\n *\n * Pipeline:\n * 1. Hash dedup (exact content match → skip)\n * 2. URI conflict (URI exists → update path)\n * 3. BM25 similarity (>0.85 → conflict detection → merge or update)\n * 4. Four-criterion gate (for P0/P1 only)\n */\nexport function guard(\n  db: Database.Database,\n  input: CreateMemoryInput & { uri?: string },\n): GuardResult {\n  const hash = contentHash(input.content);\n  const agentId = input.agent_id ?? \"default\";\n\n  // 1. Hash dedup — exact content match\n  const exactMatch = db\n    .prepare(\"SELECT id FROM memories WHERE hash = ? AND agent_id = ?\")\n    .get(hash, agentId) as { id: string } | undefined;\n\n  if (exactMatch) {\n    return { action: \"skip\", reason: \"Exact duplicate (hash match)\", existingId: exactMatch.id };\n  }\n\n  // 2. URI conflict — URI already exists, update instead of add\n  if (input.uri) {\n    const existingPath = getPathByUri(db, input.uri);\n    if (existingPath) {\n      return {\n        action: \"update\",\n        reason: `URI ${input.uri} already exists, updating`,\n        existingId: existingPath.memory_id,\n      };\n    }\n  }\n\n  // 3. BM25 similarity — find similar content\n  const similar = db\n    .prepare(\n      `SELECT m.id, m.content, m.type, rank\n       FROM memories_fts f\n       JOIN memories m ON m.id = f.id\n       WHERE memories_fts MATCH ? AND m.agent_id = ?\n       ORDER BY rank\n       LIMIT 3`,\n    )\n    .all(escapeFts(input.content), agentId) as Array<\n    Memory & { rank: number }\n  >;\n\n  if (similar.length > 0 && similar[0].rank < -10) {\n    // High similarity — check if it's a conflict (different info about same topic)\n    const existing = similar[0];\n    if (existing.type === input.type) {\n      // Same type + high similarity → merge\n      const merged = `${existing.content}\\n\\n[Updated] ${input.content}`;\n      return {\n        action: \"merge\",\n        reason: \"Similar content found, merging\",\n        existingId: existing.id,\n        mergedContent: merged,\n      };\n    }\n  }\n\n  // 4. Four-criterion gate (only for P0/P1 — identity and emotion)\n  const priority = input.priority ?? (input.type === \"identity\" ? 0 : input.type === \"emotion\" ? 1 : 2);\n  if (priority <= 1) {\n    // For high-priority memories, we're more lenient — just check basic validity\n    if (!input.content.trim()) {\n      return { action: \"skip\", reason: \"Empty content rejected by gate\" };\n    }\n  }\n\n  // All checks passed → add\n  return { action: \"add\", reason: \"Passed all guard checks\" };\n}\n\n/**\n * Escape special FTS5 characters in query\n */\nfunction escapeFts(text: string): string {\n  // Take first 100 chars, remove special chars, join with OR for flexible matching\n  const words = text\n    .slice(0, 100)\n    .replace(/[^\\w\\u4e00-\\u9fff\\s]/g, \" \")\n    .split(/\\s+/)\n    .filter((w) => w.length > 1)\n    .slice(0, 5);\n\n  if (words.length === 0) return '\"\"';\n  return words.map((w) => `\"${w}\"`).join(\" OR \");\n}\n"],"mappings":"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","names":[]}